<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Sorting Algorithms Guide</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #121212, #2c3e50);
            color: #ffffff;
            overflow-x: hidden;
        }

        header {
            background: linear-gradient(135deg, #2980b9, #2c3e50);
            color: #ffffff;
            padding: 20px 0;
            text-align: center;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        header h1 {
            margin: 0;
            font-size: 2.5em;
            text-transform: uppercase;
            letter-spacing: 2px;
            animation: fadeInDown 1s ease-in-out;
        }

        .container {
            max-width: 900px;
            margin: 40px auto;
            padding: 20px;
            background-color: #1e1e1e;
            border-radius: 15px;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.1);
            animation: fadeInUp 1s ease-in-out;
        }

        h2 {
            color: #4CAF50;
            border-bottom: 2px solid #4CAF50;
            padding-bottom: 10px;
            animation: fadeInLeft 1s ease-in-out;
        }

        ul,
        ol {
            padding-left: 20px;
        }

        ul li,
        ol li {
            margin: 10px 0;
        }

        .concept-box {
            border: 1px solid #444;
            padding: 15px;
            margin: 15px 0;
            border-radius: 15px;
            background: #2b2b2b;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.05);
            animation: fadeInRight 1s ease-in-out;
        }

        .code-link {
            font-family: monospace;
            background: #333;
            padding: 2px 4px;
            border-radius: 4px;
            color: #4CAF50;
            text-decoration: none;
        }

        .visualization {
            text-align: center;
            margin: 20px 0;
        }

        .visualization img {
            max-width: 100%;
            height: auto;
            border-radius: 15px;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.1);
        }

        a {
            color: #4CAF50;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        iframe {
            width: 100%;
            height: 400px;
            border: none;
            border-radius: 15px;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.1);
            animation: fadeInUp 1.5s ease-in-out;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeInLeft {
            from {
                opacity: 0;
                transform: translateX(-30px);
            }

            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes fadeInRight {
            from {
                opacity: 0;
                transform: translateX(30px);
            }

            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
    </style>
</head>

<body>
    <header>
        <h1>Advanced Sorting Algorithms Guide</h1>
    </header>
    <div class="container">
        <section>
            <h2>Underlying Principles</h2>
            <h3>Randomized Quick Sort</h3>
            <p><strong>Concept:</strong> Randomized Quick Sort enhances the traditional Quick Sort algorithm by
                selecting the pivot element randomly from the array. This reduces the likelihood of encountering the
                worst-case scenario, where the pivot consistently results in highly unbalanced partitions.</p>
            <p><strong>In-Place Sorting:</strong> In-place sorting means the algorithm sorts the array without requiring
                additional storage proportional to the input size. It rearranges elements within the original array,
                thus maintaining a low space complexity, typically O(log n) due to the recursive stack space.</p>
            <p><strong>Process:</strong></p>
            <ul>
                <li><strong>Partitioning:</strong> Select a pivot element randomly from the array.</li>
                <li><strong>Rearranging:</strong> Rearrange the array elements so that elements less than the pivot are
                    on its left, and elements greater than the pivot are on its right.</li>
                <li><strong>Recursive Sorting:</strong> Recursively apply the same process to the left and right
                    subarrays until the entire array is sorted.</li>
            </ul>
            <div class="visualization">
                <h4>Randomized Quick Sort Visualization</h4>
                <iframe width="560" height="315" src="https://www.youtube.com/embed/aFswaBnWKLk?si=Ll3SVCNtqAcs4-ol"
                    title="YouTube video player" frameborder="0"
                    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
                    referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
            </div>
            <p>For more information, visit this <a href="https://www.geeksforgeeks.org/quick-sort/">GeeksforGeeks
                    article on Quick Sort</a>.</p>

            <h3>Merge Sort (Top-Down)</h3>
            <p><strong>Recursive Nature:</strong> Top-Down Merge Sort follows a divide-and-conquer approach, recursively
                splitting the array into smaller subarrays until each subarray contains a single element, which is
                inherently sorted. It then merges these subarrays in a sorted manner.</p>
            <p><strong>Efficiency:</strong> Merge Sort is a stable sorting algorithm with a time complexity of O(n log
                n). Stability ensures that equal elements maintain their relative order after sorting, which is
                important for certain applications.</p>
            <p><strong>Process:</strong></p>
            <ul>
                <li><strong>Dividing:</strong> Recursively split the array into two halves until each half contains a
                    single element.</li>
                <li><strong>Merging:</strong> Merge the sorted subarrays to produce new sorted subarrays, and continue
                    this process until the entire array is merged into a single sorted array.</li>
            </ul>
            <div class="visualization">
                <h4>Top-Down Merge Sort Visualization</h4>
                <iframe width="560" height="315" src="https://www.youtube.com/embed/k3oezbZgfDs?si=FE7M9Qh4k7sDvANn"
                    title="YouTube video player" frameborder="0"
                    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
                    referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
            </div>
            <p>For more details, read this <a
                    href="https://www.tutorialspoint.com/data_structures_algorithms/merge_sort_algorithm.htm">tutorial
                    on Merge Sort</a>.</p>

            <h3>Merge Sort (Bottom-Up)</h3>
            <p><strong>Iterative Approach:</strong> Bottom-Up Merge Sort is an iterative version of the Merge Sort
                algorithm. Instead of recursively dividing the array, it starts by considering each element as a single
                subarray and iteratively merges these subarrays in pairs, progressively merging larger subarrays.</p>
            <p><strong>Memory Usage:</strong> This version of Merge Sort can be optimized to use less temporary memory
                compared to the Top-Down approach. It typically operates by merging elements directly within the
                original array, reducing the need for additional temporary storage.</p>
            <p><strong>Process:</strong></p>
            <ul>
                <li><strong>Merging Small Subarrays:</strong> Begin by treating each element as a subarray of size 1 and
                    merge adjacent subarrays to form sorted subarrays of size 2.</li>
                <li><strong>Progressive Merging:</strong> Continue merging subarrays of increasing size (e.g., 4, 8, 16,
                    etc.) until the entire array is merged into a single sorted array.</li>
            </ul>
            <div class="visualization">
                <h4>Bottom-Up Merge Sort Visualization</h4>
                <iframe width="560" height="315" src="https://www.youtube.com/embed/IN_ZOU-LK08?si=l6tSq5wiSUX0zgpn"
                    title="YouTube video player" frameborder="0"
                    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
                    referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
            </div>
            <p>Learn more from this <a
                    href="https://www.educative.io/edpresso/merge-sort-iterative-vs-recursive">Educative article on
                    Merge Sort</a>.</p>
        </section>

        <section>
            <h2>Task Details</h2>
            <h3>Step 1: Setup the Project</h3>
            <ul>
                <li><strong>Extend the Project:</strong> Start by extending the project inherited from Task 3.1. Import
                    the <a href="3.2D/Tester.cs" class="code-link">Tester.cs</a> file to access the
                    prepared <span class="code-link">Main</span> method for debugging and testing the algorithmic
                    solutions.</li>
                <li><strong>Vector Class:</strong> Ensure you have the <a href="3.2D/Vector.cs"
                        class="code-link">Vector&lt;T&gt;</a> class ready, which you implemented as part of Task 1.1P.
                </li>
            </ul>

            <h3>Step 2: Implement the Sorting Algorithms</h3>
            <p>Create three new classes for the sorting algorithms. Each class must implement the <a
                    href="3.2D/ISorter.cs" class="code-link">ISorter</a> interface and its <span
                    class="code-link">Sort&lt;K&gt;</span> method. Each class should also have a default constructor.
                You may add any extra private methods and attributes if necessary.</p>

            <h4>Randomized Quick Sort</h4>
            <ul>
                <li><strong>Pivot Selection:</strong> Implement the pivot selection using a random function. This
                    ensures that the pivot element is chosen uniformly at random from the array.</li>
                <li><strong>In-Place Sorting:</strong> Ensure that the sorting operations are performed in-place,
                    meaning that elements are rearranged within the original array without requiring additional storage.
                </li>
                <li><strong>Recursive Logic:</strong> Implement the recursive Quick Sort logic using the randomized
                    pivot selection. This involves partitioning the array and recursively sorting the partitions.</li>
            </ul>

            <h4>Merge Sort (Top-Down)</h4>
            <ul>
                <li><strong>Recursive Division:</strong> Implement the logic to recursively divide the array into
                    smaller subarrays.</li>
                <li><strong>Merging:</strong> Implement the merging logic to combine the sorted subarrays into a single
                    sorted array. This involves merging two sorted subarrays into one sorted array.</li>
            </ul>

            <h4>Merge Sort (Bottom-Up)</h4>
            <ul>
                <li><strong>Iterative Merging:</strong> Implement the logic to iteratively merge smaller subarrays into
                    larger sorted subarrays.</li>
                <li><strong>Memory Optimization:</strong> Ensure that the implementation uses memory efficiently,
                    minimizing the use of temporary storage.</li>
            </ul>

            <h3>Step 3: Testing the Algorithms</h3>
            <p>As you progress with the implementation, use the <a href="3.2D/Tester.cs"
                    class="code-link">Tester</a> class to test your sorting algorithms for potential logical issues and
                runtime errors. Testing is as important as coding, so ensure you thoroughly test your implementations.
            </p>
            <ul>
                <li><strong>Basic Test Cases:</strong> Start by testing basic cases to ensure the algorithms work as
                    expected.</li>
                <li><strong>Edge Cases:</strong> Test edge cases such as empty arrays, arrays with a single element, and
                    arrays with duplicate elements.</li>
                <li><strong>Performance:</strong> Test the performance of your algorithms with large arrays to ensure
                    they perform efficiently.</li>
            </ul>
        </section>

        <section>
            <h2>Conclusion</h2>
            <p>By following these steps, you will be able to implement and test the Randomized Quick Sort, Merge Sort
                (Top-Down), and Merge Sort (Bottom-Up) algorithms. Understanding the underlying principles and focusing
                on efficient implementation will help you achieve the task objectives and enhance your knowledge of
                advanced sorting algorithms.</p>
        </section>
    </div>
</body>

</html>